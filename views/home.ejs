<!DOCTYPE html>
<html>
<head>
  <title>Fun with algos</title>
  <link rel="stylesheet" type="text/css" href="../css/style.css">
</head>
<body>

  <P><strong><H1>#QUARANTINEANDCODE</H1></strong></P>

  <div class="arraysAsStacks">
    <h2>
      Stacks Attack
    </h2>
    <p>
      I am taking this time to have fun with algorithms and data structures; don't miss out on the fun. 
    </p>
    <p>
      This section will focus on stacks; the way that they work and some of the built-in methods of an array to implement a stack. Today, we will use a stack to see if a word is a palindrome.
    </p>

    <h3>Is this word a palindrome?</h3>

    <h5>A palindrome is a word that is spelled the same way--forward and backwards.</h5>

    <p><h4>
      To begin, I will need three variables:
    </h4></p>

    <ol>
      <li>
        letters' array - var letters = [] 
      </li>
      <li>
        words' string - var word = "racecar"
      </li>
      <li>
        rwords' empty string - var rwords = ""
      </li>
    </ol>
    <h5>PUSH</h5>
    <p>
      Once you have these variables declared, the next step is to put the letters of each word into a stack. In case you're wondering, a stack is a storage container for various data types; the data is stored and indexed in the order that it is being added FIFO(First In First Out).
    </p>
    <ul>
      <li>
        To put the items in the array, we will need a method to accomplish this. Luckily, arrays have a method built in called "push".</li>
    </ul>
    <ul>
      <li>
        To use a <i>.push()</i>, you will need to have an array created that you will "push" the values into; this is why we created the <i>letters'</i> array.
      </li>
      <li>
        The next step is to call the .push on the data that you want to be pushed in.

        i.g. review the following: letters.push(word[i]);

        This will push the characters of the word into the letters array. 
      </li>
      <li>
        The only problem is you will only get the first letter. You will need to (iterate) go through each letter of the word, if you want to see if it is indeed a palindrome.
      </li>
      <li>
        The correct implementation will requre a looping mechanism to engage with each character of the word. Many programming languages have for loops. These loops allow you to <i>"loop"</i> through an array object. (everything is an object in javascript, FYI).

        for(var i = 0; i< word.length; i++){
          letters.push(word[i]);
        }
        <br>
        What this is doing is looking at the length of a word and starting a counter at 0; you then count the length of the characters of the word and execute the .push() on each iteration adding 1 to the i value until it is equal to the total word count(word.length).  
      </li>
    </ul>

        <h5>POP</h5>

    <p>
      Now that you've added the data in the stack, we now need to get the reverse order of that word, so we can determine if they are duplicates; if they are, the word is a palindrome. An array has a method called .pop() that can be used to do this. While the <i>push</i> method is <strong>FIFO</strong>, the <i>pop</i> method is Last In First Out. 
    </p>
    <ul>
      <li>
        To use this method, you will call .pop() on the <i>letters array</i>. This will give you the word in the reverse order which we are calling <i>rword</i>.

        rword =+ letters.pop();
      </li>
      <li>
        Once again, the method will only work on the the first character of the indexed word, so we will need to create a loop that will iterate through all of the values in the array.
      </li>
      <li>For this purpose, we will use the <i>For Loop</i>.
        for(var i = 0; i < word.length; i++){
          rword += letters.pop();
        }
      </li> 
      
      <li>
        For the length of the word that you are checking, you want to pop that number of characters from the array and store it in the reverse word string <i>rword</i>.
      </li>
    </ul>
      <p>
        Now that we have both the word and the word in  revese, <i>rword</i>, we can do a comparison of the two, to determine if they are duplicates.

        If they are, the word is a palindrome.
      </p>
      
      <li>
        To compare to values in Javascript, you can use what is called a <i>comparison operator</i>. There are various operators, but in this case we will use the <i><b>"tripple equals"</b></i> comparison. 
      </li>
      <li>
        You wrap both values that you are comparing in an <i>if</i> statement. If the two values are the same, we can log to the console the word is a palindrome; they are not, we will indicate that as well.

        if(rword === word){
          console.log(word, "is a palindrome")
        }
        else{
          console.log(word, "is not a palindrome")
        }
      </li>
  </div>
  <div class="createMyStack">
    <h2>Creating a stack without using an array</h2>

    <p>
      If you want to create stack without an array, you can use a Stack class contructor.
    </p>
    <p>  
      This class will have the following methods:
    </p>  
      <ol>
        <li>
          .push()
        </li>
        <li>
          .pop()
        </li>
        <li>
          .size()
        </li>
      </ol>
    <p>
      In addition you will need to add a .count and a .storage property on this Stack object contructor using the <i>key word <b>this</b></i>. <strong>"This"</strong> is very powerful in javascript, esspecially in this case; it will allow you to dynamically attach this property to all of the objects that are created with this contructor.
    </p>
    <p>
      The next step is create the contructor function.
    </p>
    <ul>
      <li>
        //Notice that the constructor uses the capital S; this indicates it is a contructor:
        <br>
        var Stack = function(){
        <div class="marginLeft15px">
        <br>
          <b class="marginLeft15px">this.count = 0;</b>
          <br>
          <b class="marginLeft15px">this.storage = {};</b>

          <br>
          //Adds value to the end of the stack
          <br>
          this.push = function(value){
          <br>
            <p class="marginLeft15px">
            //the index for the values in the storage is being set by the count that began at 0 above.

            <br>
            this.storage[this.count] = value;
            <br>
            // here I iterate the count by 1 with ++
            <br>
            this.count++;
            </p>
          }
          </div>  
        <br>
        <div class="marginLeft15px">
            // Removes and returns the values at the end of the stack
            <br>
          this.pop = function(){
          <div class="marginLeft20px">
            if(this.count === 0){
            <br>
              <p class="marginLeft25px marginTopNeg10px"><br>
                <b>return undefinded;</b>
              </p>
            }
            <br>
            this.count--;
            <br>
            var result = this.storage[this.count];
            <br>
            <b>delete</b> this.storage[this.count];
            <br>
            <b>return</b> result
            <br>
            }
          </div>

            <p class="marginLeft15px">
            // returns the size of the stack
            <br>
            this.size = function(){
            <br>
             <b class="marginLeft20px">return this.count++</b>;
            <br> 
            }
          <br>  
            </p>
            <p class="marginLeft15px">
            // returns the value at the end of the stack.
            <br>
            this.peek = function(){
            <br>
             <b class="marginLeft20px">return this.count[this.count-1]</b>;
            <br> 
            }
          <br>  
            </p>            
          }
          </div>  
        <br>

        </div>
        }
        <br>
      </li>
    </ul>
       <p>
       Once you have your Stack constructor function, you can try it out, by calling the <i>keyword <strong>new</strong></i>.
       </p> 
      <ul>
      <li>
        The keyword <i>new</i> is used to call a new instance of an object constructor class; in this case the Stack class.
      </li>
      <li>
        //Here we create a new Stack instace called <i>newStack</i>.
        <br> 
        var newStack = new Stack();
      </li>
      <li>
        //I create an array of values that will be pushed into the the <i>newStack</i> object.
        <br>
        stackArr = [1,2,3,4,5,6,7,8,9,10,11];
      </li>
      <p>
        for(var i = 0; i < stackArr.length; i++){
        <br>
        <i class="marginLeft15px">newStack.push(stackarr[i]);</i>
        <br>
        }
      </p>
      <br>
      Call the .peek() method on <i>newStack</i>.
      <br>
      <br>
      //check the last value added to the stack(11).
      <li>
        console.log(newStack.peek())
      </li>
      //remove the last value added to the stack(11).
      <li>
        console.log(newStack.pop())
      </li>
      //check the value at the end of stack, again(10).
      <li>
        console.log(newStack.peek())
      </li>
      </ul>
      <p>
        If implemented correctly, you should have returned 10, after your .pop() removed the 11.
      </p> 
  </div>
  <h2>Working with Sets</h2>

  <p>
    The next section will focus on creating and using a Set constructor class to create set instance  collections.
  </p>
  <p>
    To create a set, you will need to create a constructor function and a collection array; this will hold your set.
    <p class="container">
      function mySet(){
        <br>
        <b class="marginLeft15px">var collection = []</b>;
        <br>
    </p> 
    <ul>
      <li>
      this.has = function(element){
      <br>
        <strong class="marginLeft15px">return (collection.indexOf(element) !== -1)</strong>
        <br>
      };
      </li>
      <li>
      this.values = function(){
      <br>
        <strong class="marginLeft15px">return collection</strong>
        <br>
      };
      </li>
      <li>
      this.add = function(element){
      <br>
        <i class="marginLeft15px">if(!this.has(element)){</i>
        <br>
        <i class="marginLeft20px">collection.push(element)</i>;
        <br>
        <b class="marginLeft20px">return true</b>;
        <p class="marginLeft15px">};</p>
        <b class="marginTopNeg10px marginLeft15px">return false</b>;
        <br>
      };
      </li>
            <li>
      this.remove = function(element){
      <br>
        <i class="marginLeft15px">if(this.has(element)){</i>
        <br>
        <i class="marginLeft20px">index = colleciton.indexOf(element)</i>;
        <br>
        <i class="marginLeft20px">
         collection.splice(index, 1); 
        </i>
        <br>
        <b class="marginLeft20px">return false</b>;
        <p class="marginLeft15px">};</p>
      
      };
      </li> 
      <li>
      this.size = function(){
      <br>
        <strong class="marginLeft15px">return collection.length</strong>;
        <br>
      };
      </li>
      <li>
      this.union = function(otherSet){
      <br>
        <i class="marginLeft15px">var unionSet = new mySet()</i>;
        <br>
        <i class="marginLeft15px">var firstSet = this.values()</i>;
        <br>
        <i class="marginLeft15px">var secondSet = otherSet.values()</i>;
        <br>
        <br>
        <i class="marginLeft15px">firstSet.forEach(function(e){
        </i>
        <br>
        <i class="marginLeft20px">unionSet.add(e)</i>;
        <br>
        <i class="marginLeft15px">})</i>
        <br>
        <b class="marginTopNeg10px marginLeft15px">return unionSet</b>;
        <br>
      };
      </li>
      <li>
      this.intersection = function(otherSet){
      <br>
        <i class="marginLeft15px">var intersectionSet = new mySet()</i>;
        <br>
        <i class="marginLeft15px">var firstSet = this.values()</i>;
        <br>
      
        <br>
        <i class="marginLeft15px">firstSet.forEach(function(e){
        </i>
        <br>
        <i class="marginLeft20px">if(otherSet.has(e)){</i>
        <br>
        <i class="marginLeft25px">intersectionSet.add(e)</i>
        
        <br>
        <i class="marginLeft20px">}</i>
        <br>
        <i class="marginLeft15px">})</i>;
        <br>
        <b class="marginTopNeg10px marginLeft15px">return intersectionSet</b>;
        <br>
      };
      </li>
      <li>
      this.difference = function(otherSet){
      <br>
        <i class="marginLeft15px">var differentSet = new mySet()</i>;
        <br>
        <i class="marginLeft15px">var firstSet = this.values()</i>;
        <br>
      
        <br>
        <i class="marginLeft15px">firstSet.forEach(function(e){
        </i>
        <br>
        <i class="marginLeft20px">if(!otherSet.has(e)){</i>
        <br>
        <i class="marginLeft25px">differentSet.add(e)</i>
        
        <br>
        <i class="marginLeft20px">}</i>
        <br>
        <i class="marginLeft15px">})</i>;
        <br>
        <b class="marginTopNeg10px marginLeft15px">return differentSet</b>;
        <br>
      };
      </li>
      <li>
      <i>this.subset = function(otherSet){</i>
      <br>
      <i class="marginLeft15px">var firstSet = this.values()</i>;
      <br>
        <i class="marginLeft15px"><strong>return</strong> firstSet.every(function(value){</i>
        <br>
        <i class="marginLeft25px"><strong>return</strong> otherSet.has(value)</i>
        <br>
      <i class="marginLeft15px">};</i>
      </li>
      <li>
      <i>};</i>
      <br>
      </li>                                     
    </ul>
      }
    <div>
    <p>
    var set1 = new mySet();
      <br>
    var set2 = new mySet();
    <br>
    var arrayA = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'];
    <br>
    var arrayC = ['l','m','n','o','p','q','r','s'];
    <br>
    <br>
    <i>
    for(var i = 0; i < arrayA.length; i++){
    </i>
    <br>
    <i class="marginLeft15px">set1.add(arrayA[i])</i>;
    <br>
    <i class="marginLeft15px">console.log(set1.values())</i>;
    <br>
    </i>
    <i>}</i>
    <br>
    <i>
    for(var i = 0; i < arrayC.length; i++){
    </i>
    <br>
    <i class="marginLeft15px">set2.add(arrayC[i])</i>;
    <br>
    <i class="marginLeft15px">console.log(set2.values())</i>;
    <br>
    <i>}</i>
    <br>
    <i>
    if(set2.subset(set1)){
    </i>
    <br>
    <i class="marginLeft15px">console.log('it is a subset.')</i>;
    <br>
    }else{
    <br>
    <i>console.log('it is not a subset.')</i>;
    <br>
    <i>}</i>
    <br>
    <br>
    </p>
    </div>
  </p>



  <script src="../js/main.js" type="text/javascript"></script>
</body>
</html>